head	1.2;
access;
symbols
	r1:1.1.1.1 mhelal:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2008.05.11.13.55.54;	author mhelal;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.06.02.40.53;	author mhelal;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.05.06.02.40.53;	author mhelal;	state Exp;
branches;
next	;


desc
@@


1.2
log
@search space error
@
text
@/****************************************************************
* Author: Manal Helal                                           *
* Last Modification Date: Fri 12 Jan 2007 03:39:51 AM EST       *
* Project : MMSA - Multiple Sequence Alignment Based on 	       *
* 					Mathematics of Arrays - PhD Experimentation		 *
* File: moa.c
* Description: contain the basic MOA functions used in 		    *
*       this project                                            *
* Function:
*		Tau
*		Gamma
*     deleteMOA
*     Gamma_Inverse
*     createMOAStruct
*     printMOA
*     isLowerBorderCell
*     isHigherBorderCell
*     isHigherBorderCellandNotLower
*     MOAGetLowerNeighbors
*     NextIndex
*     copyIndicesElm
*     copyIndices
*     Take
*     TakeInd
*     Drop
*     DropInd
*     VecIsEqual
*     MOAGetHigherNeighbors
****************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include "globals.h"
#include "moa.h"
#include "utils.h"


/*****************************************************
	Function: createMOAStruct
		Allocate memory for MOA record and initialize its elements.
*****************************************************/
void createMOAStruct(MOA_rec * * MOA_val) {

  (*MOA_val) = mmalloc(sizeof *(*MOA_val));
  (*MOA_val)->dimn = 1;
  (*MOA_val)->shape = NULL;
  (*MOA_val)->indexes = NULL;
  (*MOA_val)->elements = NULL;
}

void createMOA(long * shape, long dimn, MOA_rec * MOA_val, int callFlag, int cellValue)
{
  long i;
  printf ("%ld (%ld, %ld, %ld)\n", dimn, shape[0], shape[1], shape[2]);

  MOA_val->elements_ub = Tau(shape, dimn);
  if (MOA_val->elements_ub == 0) {
    mprintf(1, "The smallest type of MOA array is a scalar that requires at least one element! NO MOA type supports zero element list!\n", threadnum);
    return;
  }
  MOA_val->dimn = dimn;
  if (dimn == 0) {
    MOA_val->shape = mcalloc (1, sizeof *MOA_val->shape);
    MOA_val->shape[0] = 1;
  }
  else {
    MOA_val->shape = mcalloc(MOA_val->dimn, sizeof *MOA_val->shape);
    for (i = 0; i< dimn; i++) {
      MOA_val->shape[i] = shape[i];
    }
  }
  /* if callFlag is -1 means, don't allocate memory for the tensor, this is used with sparse arrays implementation. */
  
  if (callFlag != -1) {
    
    /*MOA_val->elements_ub =  Tau(shape, dimn); */
    MOA_val->elements = mcalloc (MOA_val->elements_ub, sizeof *MOA_val->elements);
    MOA_val->indexes = mcalloc (MOA_val->elements_ub, sizeof *MOA_val->indexes);    
    for (i = 0; i< MOA_val->elements_ub; i++) {	MOA_val->elements[i].prev_ub = 0;	
	MOA_val->elements[i].prev = NULL;
	MOA_val->indexes[i] = i;
	/* if callFlag is 0, means initialize cell values with 0, which is done with mcalloc */	if (callFlag == 1) {
	/* if callFlag is 1 meaning, initialize the array values with the cellValue argument value */
	  MOA_val->elements[i].val = cellValue;
	}
    }
  }
  
}
/* ***************************************************************
* Function Name:  Tau
* Description: Returns Number of elements in an MOA structure 
*       based on dimension (array_ub) and shape (array_in) - regular MOA
*****************************************************************/

long Tau (long * array_in, long array_ub) {
	long rslt, i;
	rslt = array_in[0];
	for ( i = 1; i< array_ub; i++) {
		rslt = rslt * array_in[i];	
	}
	return (rslt);
} /* end Tau */


/*********************************************************************
	Function: deleteMOA
		free allocated memory for MOA record
*********************************************************************/
void deleteMOA(MOA_rec * MOA) {
	long i;
#ifndef NDEBUG
	int dbglevel = 30;
#endif

	if (MOA != NULL) {	
#ifndef NDEBUG
		mprintf (dbglevel, "deleteMOA 1\n", 1);
#endif
		if (MOA->elements != NULL) {
#ifndef NDEBUG
			mprintf (dbglevel, "deleteMOA 2\n", 1);
#endif
			for (i = 0; i< MOA->elements_ub; i++) {
#ifndef NDEBUG
				mprintf (dbglevel, "deleteMOA 3\n", 1);
#endif
				if ((MOA->elements[i].prev_ub > 0) && (MOA->elements[i].prev != NULL)) {
					free(MOA->elements[i].prev);
				}
			}
			free(MOA->elements);
#ifndef NDEBUG
			mprintf (dbglevel, "deleteMOA 4\n", 1);
#endif
		}
		if (MOA->shape != NULL)
			free(MOA->shape);
#ifndef NDEBUG
		mprintf (dbglevel, "deleteMOA 5\n", 1);
#endif
		if (MOA->indexes != NULL) {
			free(MOA->indexes);
		}
#ifndef NDEBUG
		mprintf (dbglevel, "deleteMOA 6\n", 1);
#endif
    
		free(MOA);
#ifndef NDEBUG
		mprintf (dbglevel, "deleteMOA 7\n", 1);
#endif
	}
}

/* ***************************************************************
* Function: Gamma
* Description: Get flay index of MOA array
*****************************************************************/
long Gamma (long * m_index, long ind_ub, long * arr_shape, long shape_ub, int Front) {
	long rslt, i;
	rslt = m_index[shape_ub - 1];
	for (i = shape_ub - 2; i>=0;i--) {
		rslt = (rslt * arr_shape[i]) + m_index[i];
   	}
	return rslt;

}

/***************************************************************
 **********************  Gamma Inverse************************
 *************************************************************/

int Gamma_Inverse (long ind, long * arr_shape, long shape_ub, long * * rslt, int thrd) {
	long i, ind_temp;
	div_t div_result;
	char msg[MID_MESSAGE_SIZE];

	if (ind >= Tau(arr_shape, shape_ub)) {
		sprintf (msg, "Gamma_Inverse: The index is beyond the upper bound of the array of the defined shape! (%ld/%ld)\n", ind, Tau(arr_shape, shape_ub));
		mprintf(0, msg, thrd);
		return -1;
	}
	(*rslt) = malloc (shape_ub * sizeof *(*rslt) );
	ind_temp = ind;
	for (i = 0; i< shape_ub; i ++) {
		div_result = div(ind_temp, arr_shape[i]);
		(*rslt)[i] = div_result.rem; /* ind_temp Mod arr_shape->GetAt(i) */
		ind_temp = div_result.quot; /* ind_temp \ arr_shape->GetAt(i); */
	}
	return 0;
} /* end Gamma_Inverse */



void printMOA_Matrix(int dbglevel, int ident, void * elements, int elm_type, long total_elements, long first_dimn, char * * sequences) {
#ifndef NDEBUG
	long i, j, dim2cnt, elm_value,  * MOA_indexes;
	char msg[MID_MESSAGE_SIZE];
	MOA_elm * MOA_elements;
	
	if (elm_type == 0) MOA_elements = elements;
	else MOA_indexes = elements;
	for (j = 0; j < ident; j++) 
		mprintf(dbglevel, "   ", 1);
	mprintf(dbglevel, "  ", 1);
	for (j = 0; j < first_dimn; j++) {
		sprintf(msg, "     %c", sequences[0][j]);
		mprintf (dbglevel, msg, 1);
	}
	mprintf (dbglevel, "\n", 1);
	for (j = 0; j < ident; j++) 
		mprintf(dbglevel, "   ", 1);
	mprintf(dbglevel, "  ", 1);
	for (j = 0; j < first_dimn; j++) {
		mprintf (dbglevel, "______", 1);
	}
	mprintf (dbglevel, "\n", 1);
	dim2cnt = 0;
	for (j = 0; j < ident; j++) 
		mprintf(dbglevel, "   ", 1);
	sprintf(msg, "%c|", sequences[1][dim2cnt]);
	mprintf (dbglevel, msg, 1);
	dim2cnt ++;	
	for (i = 0; i < total_elements; i++) {
		if (i>0 && (i%first_dimn) == 0) {
			mprintf (dbglevel, "\n", 1);
			for (j = 0; j < ident; j++) 
				mprintf(dbglevel, "   ", 1);
			sprintf(msg, "%c|", sequences[1][dim2cnt]);
			mprintf (dbglevel, msg, 1);
			dim2cnt ++;	
		}
		if (elm_type == 0) elm_value = MOA_elements[i].val;
		else elm_value = MOA_indexes[i];
		sprintf(msg, " %5ld", elm_value);
		mprintf (dbglevel, msg, 1);
	}
	mprintf (dbglevel, "\n\n", 1);
	for (j = 0; j < ident; j++) 
		mprintf(dbglevel, "___", 1);
	mprintf(dbglevel, "__", 1);
	for (j = 0; j < first_dimn; j++) {
		mprintf (dbglevel, "______", 1);
	}
	mprintf (dbglevel, "\n", 1);
#endif
}

int printMOA_Sequences(int dbglevel, int ident, long dimn, long *ind, char * * sequences, MOA_rec * MOA, int elm_type) {
#ifndef NDEBUG
	long i, d, k;
	char msg[MID_MESSAGE_SIZE];
	
	if (dimn > 1) {
		for (i = 0; i < ident; i++) 
			mprintf(dbglevel, "   ", 1);
		sprintf(msg, "[%c]", sequences[dimn][ind[dimn]]);
		mprintf (dbglevel, msg, 1);
		mprintf (dbglevel, "\n", 1);
		ident++;
		ident = printMOA_Sequences(dbglevel, ident, dimn-1, ind, sequences, MOA, elm_type);
	}
	if (dimn == 1) {
		d = 1;
		k = 0;
		for (i = 0; i < MOA->dimn; i++) {
			k += d * ind[i];
			d *= MOA->shape[i];
		}
		if (elm_type == 0)
			printMOA_Matrix(dbglevel, ident, &(MOA->elements[k]), elm_type, MOA->shape[0] * MOA->shape[1], MOA->shape[0], sequences);
		else 
			printMOA_Matrix(dbglevel, ident, &(MOA->indexes[k]), elm_type, MOA->shape[0] * MOA->shape[1], MOA->shape[0], sequences);
	}
#endif
	return 0;
}

void printMOA_dimn(int dbglevel, long dimn, long * ind, char * * sequences, MOA_rec * MOA, int elm_type) {
#ifndef NDEBUG
	long i, j;
	int ident;
	
	for (i = 0; i < MOA->shape[2] ; i++) {
		ident = printMOA_Sequences(dbglevel, 0, dimn, ind, sequences, MOA, elm_type);
		ind[2]++;
	}
	ind[2] = 0;
	for (i = 3; i < MOA->dimn; i++) {
		while (ind[i]< MOA->shape[i] - 1) {
			ind[i]++;
			for (j = i; j > 3; j--) ind[j-1] = 0;
			printMOA_dimn (dbglevel, dimn, ind, sequences, MOA, elm_type);
		}
	}
#endif
}
void printMOA (int dbglevel, MOA_rec * MOA, char * * sequences, int elm_type) { 
#ifndef NDEBUG
	long i, dimn, * ind;
	char msg[MID_MESSAGE_SIZE];

	/* elm_type = 0 to print MOA elements else (=1) to print MOA Indexes.*/
	
	/* allocate memory for indexes of tensor.*/
	ind = NULL;
	ind =  mmalloc (MOA->dimn * sizeof *ind);
	if (ind == NULL) 
		return;
	
	/* Print sequences incase of printing MOA elements only. */
	if ((elm_type == 0) && (sequences != NULL))
		PrintSequencies (dbglevel, MOA->dimn, sequences, MOA->shape);

	if (elm_type == 0)
		sprintf(msg, "\n The Tensor of Dimn %ld & elements %ld & Shape: ", MOA->dimn, MOA->elements_ub);
	else 
		sprintf(msg, "\n The Relative Indices of Tensor of Dimn %ld & elements %ld & Shape: ", MOA->dimn, MOA->elements_ub);
	mprintf (dbglevel, msg, 1);
	for (i = 0; i < MOA->dimn; i++) {
		ind[i] = 0;
		sprintf(msg, " %ld ", MOA->shape[i]);
		mprintf (dbglevel, msg, 1);
	}
	mprintf(dbglevel, ":\n\n", 1);
	dimn = MOA->dimn - 1;
	
	printMOA_dimn(dbglevel, dimn, ind, sequences, MOA, elm_type);

	/* Free memory of indexes */
	if (ind != NULL) 
		free (ind);
#endif
}

void printMOA1 (MOA_rec * MOA, int elm_type) { 
  long i, j, lcnt, dim1cnt, dim2cnt, dim3cnt, * ind;

  char msg[MID_MESSAGE_SIZE];

  
  ind = NULL;
  ind =  mmalloc (MOA->dimn * sizeof *ind);
  if (ind == NULL) 
    return;

  
if (elm_type == 0)
		sprintf(msg, "\n The Tensor of Dimn %ld & elements %ld & Shape: ", MOA->dimn, MOA->elements_ub);
	else 
		sprintf(msg, "\n The Relative Indices of Tensor of Dimn %ld & elements %ld & Shape: ", MOA->dimn, MOA->elements_ub);
	mprintf (1, msg, threadnum);
  for (i = 0; i < MOA->dimn; i++) {
    if (i == 0)
      ind[i] = MOA->shape[i];
    else
      ind[i] = MOA->shape[i] * ind[i-1];
    sprintf(msg, " %ld ", MOA->shape[i]);
		mprintf (1, msg, threadnum);
  }

  dim1cnt = dim2cnt = dim3cnt = 0;
  /* print indices for dimn 1 */
  mprintf(1, ": \n", threadnum);
  /* leave 7 spaces for the 2nd dimension indices */
  mprintf(1, "       ", threadnum);	
  /* leave 2 spaces for each < for ewach dimension in the tensor*/
  for (j = 0; j < MOA->dimn; j++) 
    mprintf(1, "  ", threadnum);
   
  for (j = 0; j < MOA->shape[0]; j++) {
    sprintf(msg, "%5ld ", dim1cnt);
		mprintf (1, msg, threadnum);
    dim1cnt ++;
  }
  /* print 3rd dimension indices */
  sprintf(msg, " %9ld", dim3cnt);
	mprintf (1, msg, threadnum);
  dim3cnt ++;	
  if (dim3cnt > MOA->shape[2] - 1)
    dim3cnt = 0;
 
  /* print separator line */
  dim1cnt = 0;
  mprintf(1, "\n", threadnum);
  /* leave 7 spaces for the 2nd dimension indices & more for the end */
  mprintf(1, "___________________", threadnum);	
  /* leave 2 spaces for each < for ewach dimension in the tensor */
  for (j = 0; j < MOA->dimn; j++) 
    mprintf(1, "__", threadnum);
   
  for (j = 0; j < MOA->shape[0]; j++) {
    mprintf(1, "______", threadnum);	
    dim1cnt ++;
  }
  mprintf(1, "\n", threadnum);
  /* print 2nd dimension indices */
  sprintf(msg, "%5ld| ", dim2cnt);
	mprintf (1, msg, threadnum);
  dim2cnt ++;	
  for (j = 0; j < MOA->dimn; j++) 
    mprintf(1, "< ", threadnum);			
  
  for (i = 0; i < MOA->elements_ub; i++) {
	if (elm_type == 0)
    		sprintf(msg, "%5ld ", MOA->elements[i].val);
	else
    		sprintf(msg, "%5ld ", MOA->indexes[i]);
		mprintf (1, msg, threadnum);
    for (j = MOA->dimn - 1; j >= 0; j--) 
      if (((i+1) %  ind[j]) == 0) 
	mprintf(1, " >", threadnum);
    lcnt = 0;
    for (j = MOA->dimn - 1; j >= 0; j--) 
      if ((i+1) < MOA->elements_ub - 1) 
	if (((i+1) %  ind[j]) == 0) 
	  lcnt ++;
	
    if (lcnt > 0) {
      if (lcnt == 2) {
	/* print 3rd dimension indices */
	sprintf(msg, " %5ld", dim3cnt);
	mprintf (1, msg, threadnum);
	dim3cnt ++;	
	if (dim3cnt > MOA->shape[2] - 1)
	  dim3cnt = 0;
      }
      if (dim2cnt == 0) {
	/* print separator line */
	dim1cnt = 0;
	mprintf(1, "\n", threadnum);
	/* leave 7 spaces for the 2nd dimension indices & more for the end */
	mprintf(1, "___________________", threadnum);	
	/* leave 2 spaces for each < for ewach dimension in the tensor */
	for (j = 0; j < MOA->dimn; j++) 
	  mprintf(1, "__", threadnum);
   
	for (j = 0; j < MOA->shape[0]; j++) {
	  mprintf(1, "______", threadnum);	
	  dim1cnt ++;
	}
      }
      mprintf(1, "\n", threadnum);
      /* print 2nd dimension indices */
      sprintf(msg, "%5ld| ", dim2cnt);
			mprintf (1, msg, threadnum);
      dim2cnt ++;	
      if (dim2cnt > MOA->shape[1] - 1)
				dim2cnt = 0;
      for (j = 0; j <  (MOA->dimn - lcnt); j++)
				mprintf(1, "  ", threadnum); 		
      for (j = 0; j <  lcnt; j++)
				mprintf(1, "< ", threadnum);
    }    
  }
  mprintf(1, "\n", threadnum);
  if (ind != NULL) 
		free (ind);

}

void printMOA_scr (MOA_rec * MOA, int elm_type) { 
  long i, j, lcnt, dim1cnt, dim2cnt, dim3cnt, * ind;


  
  ind = NULL;
  ind =  mmalloc (MOA->dimn * sizeof *ind);
  if (ind == NULL) 
    return;

  
if (elm_type == 0)
		printf("\n The Tensor of Dimn %ld & elements %ld & Shape: ", MOA->dimn, MOA->elements_ub);
	else 
		printf("\n The Relative Indices of Tensor of Dimn %ld & elements %ld & Shape: ", MOA->dimn, MOA->elements_ub);
  for (i = 0; i < MOA->dimn; i++) {
    if (i == 0)
      ind[i] = MOA->shape[i];
    else
      ind[i] = MOA->shape[i] * ind[i-1];
    printf(" %ld ", MOA->shape[i]);
  }

  dim1cnt = dim2cnt = dim3cnt = 0;
  /* print indices for dimn 1 */
  printf(": \n");
  /* leave 7 spaces for the 2nd dimension indices */
  printf("       ");	
  /* leave 2 spaces for each < for ewach dimension in the tensor*/
  for (j = 0; j < MOA->dimn; j++) 
    printf("  ");
   
  for (j = 0; j < MOA->shape[0]; j++) {
    printf("%5ld ", dim1cnt);
		
    dim1cnt ++;
  }
  /* print 3rd dimension indices */
  printf(" %9ld", dim3cnt);
  dim3cnt ++;	
  if (dim3cnt > MOA->shape[2] - 1)
    dim3cnt = 0;
 
  /* print separator line */
  dim1cnt = 0;
  printf("\n");
  /* leave 7 spaces for the 2nd dimension indices & more for the end */
  printf("___________________");	
  /* leave 2 spaces for each < for ewach dimension in the tensor */
  for (j = 0; j < MOA->dimn; j++) 
    printf("__");
   
  for (j = 0; j < MOA->shape[0]; j++) {
    printf("______");	
    dim1cnt ++;
  }
  printf("\n");
  /* print 2nd dimension indices */
  printf("%5ld| ", dim2cnt);
	
  dim2cnt ++;	
  for (j = 0; j < MOA->dimn; j++) 
    printf("< ");			
  
  for (i = 0; i < MOA->elements_ub; i++) {
	if (elm_type == 0)
    		printf("%5ld ", MOA->elements[i].val);
	else
    		printf("%5ld ", MOA->indexes[i]);
		
    for (j = MOA->dimn - 1; j >= 0; j--) 
      if (((i+1) %  ind[j]) == 0) 
	printf(" >");
    lcnt = 0;
    for (j = MOA->dimn - 1; j >= 0; j--) 
      if ((i+1) < MOA->elements_ub - 1) 
	if (((i+1) %  ind[j]) == 0) 
	  lcnt ++;
	
    if (lcnt > 0) {
      if (lcnt == 2) {
	/* print 3rd dimension indices */
	printf(" %5ld", dim3cnt);
	
	dim3cnt ++;	
	if (dim3cnt > MOA->shape[2] - 1)
	  dim3cnt = 0;
      }
      if (dim2cnt == 0) {
	/* print separator line */
	dim1cnt = 0;
	printf("\n");
	/* leave 7 spaces for the 2nd dimension indices & more for the end */
	printf("___________________");	
	/* leave 2 spaces for each < for ewach dimension in the tensor */
	for (j = 0; j < MOA->dimn; j++) 
	  printf("__");
   
	for (j = 0; j < MOA->shape[0]; j++) {
	  printf("______");	
	  dim1cnt ++;
	}
      }
      printf("\n");
      /* print 2nd dimension indices */
      printf("%5ld| ", dim2cnt);
			
      dim2cnt ++;	
      if (dim2cnt > MOA->shape[1] - 1)
				dim2cnt = 0;
      for (j = 0; j <  (MOA->dimn - lcnt); j++)
				printf("  "); 		
      for (j = 0; j <  lcnt; j++)
				printf("< ");
    }    
  }
  printf("\n");
  if (ind != NULL) 
		free (ind);

}

void printMOAIndices (MOA_rec * MOA) { 
#ifndef NDEBUG
  long i, j, lcnt, dim1cnt, dim2cnt, dim3cnt, * ind;
  char msg[MID_MESSAGE_SIZE];
  
  ind = NULL;
  ind =  mmalloc (MOA->dimn * sizeof *ind);
  if (ind == NULL) 
    return;

  sprintf(msg, "\n The Relative Indices of Tensor of Dimn %ld & elements %ld & Shape: ", MOA->dimn, MOA->elements_ub);
	mprintf (1, msg, threadnum);
  for (i = 0; i < MOA->dimn; i++) {
    if (i == 0)
      ind[i] = MOA->shape[i];
    else
      ind[i] = MOA->shape[i] * ind[i-1];
    sprintf(msg, " %ld ", MOA->shape[i]);
		mprintf (1, msg, threadnum);
  }

  dim1cnt = dim2cnt = dim3cnt = 0;
  /* print indices for dimn 1 */
  mprintf(1, ": \n", threadnum);
  /* leave 7 spaces for the 2nd dimension indices */
  mprintf(1, "       ", threadnum);	
  /* leave 2 spaces for each < for ewach dimension in the tensor*/
  for (j = 0; j < MOA->dimn; j++) 
    mprintf(1, "  ", threadnum);
   
  for (j = 0; j < MOA->shape[0]; j++) {
    sprintf(msg, "%5ld ", dim1cnt);
		mprintf (1, msg, threadnum);
    dim1cnt ++;
  }
  /* print 3rd dimension indices */
  sprintf(msg, " %9ld", dim3cnt);
	mprintf (1, msg, threadnum);
  dim3cnt ++;	
  if (dim3cnt > MOA->shape[2] - 1)
    dim3cnt = 0;
 
  /* print separator line */
  dim1cnt = 0;
  mprintf(1, "\n", threadnum);
  /* leave 7 spaces for the 2nd dimension indices & more for the end */
  mprintf(1, "___________________", threadnum);	
  /* leave 2 spaces for each < for ewach dimension in the tensor */
  for (j = 0; j < MOA->dimn; j++) 
    mprintf(1, "__", threadnum);
   
  for (j = 0; j < MOA->shape[0]; j++) {
    mprintf(1, "______", threadnum);	
    dim1cnt ++;
  }
  mprintf(1, "\n", threadnum);
  /* print 2nd dimension indices */
  sprintf(msg, "%5ld| ", dim2cnt);
	mprintf (1, msg, threadnum);
  dim2cnt ++;	
  for (j = 0; j < MOA->dimn; j++) 
    mprintf(1, "< ", threadnum);			
  
  for (i = 0; i < MOA->elements_ub; i++) {
    sprintf(msg, "%5ld ", MOA->indexes[i]);
		mprintf (1, msg, threadnum);
    for (j = MOA->dimn - 1; j >= 0; j--) 
      if (((i+1) %  ind[j]) == 0) 
	mprintf(1, " >", threadnum);
    lcnt = 0;
    for (j = MOA->dimn - 1; j >= 0; j--) 
      if ((i+1) < MOA->elements_ub - 1) 
	if (((i+1) %  ind[j]) == 0) 
	  lcnt ++;
	
    if (lcnt > 0) {
      if (lcnt == 2) {
	/* print 3rd dimension indices */
	sprintf(msg, " %5ld", dim3cnt);
	mprintf (1, msg, threadnum);
	dim3cnt ++;	
	if (dim3cnt > MOA->shape[2] - 1)
	  dim3cnt = 0;
      }
      if (dim2cnt == 0) {
	/* print separator line */
	dim1cnt = 0;
	mprintf(1, "\n", threadnum);
	/* leave 7 spaces for the 2nd dimension indices & more for the end */
	mprintf(1, "___________________", threadnum);	
	/* leave 2 spaces for each < for ewach dimension in the tensor */
	for (j = 0; j < MOA->dimn; j++) 
	  mprintf(1, "__", threadnum);
   
	for (j = 0; j < MOA->shape[0]; j++) {
	  mprintf(1, "______", threadnum);	
	  dim1cnt ++;
	}
      }
      mprintf(1, "\n", threadnum);
      /* print 2nd dimension indices */
      sprintf(msg, "%5ld| ", dim2cnt);
			mprintf (1, msg, threadnum);
      dim2cnt ++;	
      if (dim2cnt > MOA->shape[1] - 1)
				dim2cnt = 0;
      for (j = 0; j <  (MOA->dimn - lcnt); j++)
				mprintf(1, "  ", threadnum); 		
      for (j = 0; j <  lcnt; j++)
				mprintf(1, "< ", threadnum);
    }    
  }
  mprintf(1, "\n", threadnum);
  if (ind != NULL) 
		free (ind);
#endif
}

/*****************************************************************
	Function: isLowerBorderCell
*****************************************************************/
int isLowerBorderCell (long * index, long dimn) {
  long j;
  int borderCell = 0;
  for (j = 0; j< dimn; j++) {
    if (index[j] == 0)
      borderCell = 1;
  }
  return borderCell;
}
/***************************************************************
	Function: isHigherBorderCell
***************************************************************/
int isHigherBorderCell (long * index, long dimn, long * shape) {
  long j;
  int borderCell = 0;

  for (j = 0; j< dimn; j++) {
    if (index[j] == (shape[j] -1))
      borderCell = 1;
  }
  return borderCell;
}
/**************************************************************************
	Function: isHigherBorderCellandNotLower
**************************************************************************/
int isHigherBorderCellandNotLower (long * index, long dimn, long * shape) {
  long j;
  int HigherBorderCell = 0;
  int LowerBorderCell = 0;
  for (j = 0; j< dimn; j++) {
    if (index[j] == (shape[j] -1))
      HigherBorderCell = 1;
    if (index[j] == 0)
      LowerBorderCell = 1;
  }
  if ((HigherBorderCell == 1) && (LowerBorderCell == 0))
    return 1;
  else
    return 0;
}

/* ***************************************************************
 **********************   VecIsEqual   *************************
 ***************************************************************/
int VecIsEqual (long * Array_1, long array1_ub, long * Array_2, long array2_ub) {
	int rslt;
	long i;

	if (array1_ub != array2_ub) 
		rslt = 0; /*Not Equal*/
	else
		rslt = 1;/*Equal*/
  
	for (i = 0 ; (i < array1_ub) && (rslt); i++ ) {
		if (Array_1[i] != Array_2[i]) {
			rslt = 0;/*Not Equal*/
		}
	}
	return (rslt);
}

/* ***************************************************************
 **********************    MOAGetLowerNeighbors ****************
 ***************************************************************/
long MOAGetLowerNeighbors (long * startingIndex, MOA_rec * MOA_in, MOA_rec * * rslt) {
	long i, idx, * ind, * ind2, * ind3;
	int l1_finished, ret, noDrop;
#ifndef NDEBUG
	char msg[MID_MESSAGE_SIZE];
	int dbglevel = 5;
#endif
	
	ind = NULL;
	ind =  mcalloc (sizeof *ind, MOA_in->dimn);
	if (ind == NULL) 
		return 0;

	ind2 = NULL;
	ind2 =  mcalloc (sizeof *ind2, MOA_in->dimn);
	if (ind2 == NULL) 
		return 0;

	ind3 = NULL;
	ind3 =  mcalloc (sizeof *ind3, MOA_in->dimn);
	if (ind3 == NULL) 
		return 0;

#ifndef NDEBUG
	sprintf(msg, "in MOAGetLowerNeighbors dimn %ld\n", MOA_in->dimn);  
	mprintf(dbglevel, msg, 1);
#endif
	MOA_rec * rslt2;
	noDrop = 1;
	//printf("(");
	for (i = 0; i < MOA_in->dimn; i++) {
		/*ind is the vector passed to take to decide how much to take from each dimension from the starting position, because we are getting only 1 distance away neighbors, it should be = 2, to get the current cell and it's direct neighbor*/
		ind[i] = 2;
		/*ind2 here is the vector passed to drop function to decide how much to drop from each dimension, it might be nothing and drop operation ommitted, if one of the neighbors is at the all zeros coordinates, hence the noDrop flag.*/
		if (startingIndex[i] > 0)
			ind2[i] = startingIndex[i] - 1;
		else
			return 0;
		if (ind2[i] > 0)
      			noDrop = 0;
		//printf (" %ld ", ind2[i]);
	}
	//printf (") Drop Vector from shape: (");
  
	if (noDrop == 0) {
		createMOAStruct (&rslt2);
		ret = Drop(ind2, MOA_in->dimn, MOA_in, &rslt2);  
		//printMOA_scr(rslt2, 1);
		if (ret >= 0) {
			createMOAStruct (rslt);
			ret = Take(ind, rslt2->dimn, rslt2, rslt);
  		}
  
  		if (ret < 0) 
    			return 0;
  
  		for (i = 0; i < MOA_in->dimn; i++) {
			//printf (" %ld ", MOA_in->shape[i]);
    			ind[i] = 0; /*this is the starting index of the neighbors MoA structure, and used as the iterator index to */
    			ind2[i] = 1; /*this is the ending index of the neighbors MoA structure, always 1 because of getting the direct neighbors only shape -1*/
    			ind3[i] = 2;/*this is the shape vector of the neighbors MoA structure, always 2 because of getting the direct neighbors only*/
  		}
  
  		l1_finished = 0;
  		i = 0;
		
		//for (i=0;i<rslt2->elements_ub;i++)
		//	printf (" %ld ", rslt2->indexes[i]);
		//printf (") after drop \n");
  		if ((*rslt)->elements_ub > 0) {
    			while (l1_finished == 0) {
      				idx = Gamma(ind, rslt2->dimn, rslt2->shape, rslt2->dimn, 1);
      				(*rslt)->indexes[i] =  rslt2->indexes[idx];
      				i++;
      				l1_finished = VecIsEqual(ind, MOA_in->dimn, ind2, MOA_in->dimn);
      				NextIndex(ind3, MOA_in->dimn, ind);
	    		}
	  	}
		deleteMOA (rslt2);  
 	}
 	else {
			createMOAStruct (rslt);
			ret = Take(ind, MOA_in->dimn, MOA_in, rslt);
 	} 
	//printf (")\n (");
	//for (i=0;i<(*rslt)->elements_ub;i++)
	//	printf (" %ld ", (*rslt)->indexes[i]);
	//printf (") after take\n");
	fflush(stdout);
	if (ind != NULL)
		free(ind);
	if (ind2 != NULL)
		free(ind2);
	if (ind3 != NULL)
		free(ind3);
  return (*rslt)->elements_ub-1;
}
/* ***************************************************************
 **************************** NextIndex ************************
 ***************************************************************/

void NextIndex (long * shape, long shape_ub, long * Prev_Index) {
	long i, j;
	long * rslt = NULL;

	rslt = mmalloc (shape_ub * sizeof *rslt);

	/* copy the previous index ==============================*/
	for (i = 0; i < shape_ub; i++){
		rslt[i] = Prev_Index[i];
	}

	for (i = 0; i < shape_ub; i++){
		if (Prev_Index[i] < shape[i] - 1) {
			rslt[i] = Prev_Index[i] + 1;
			if (i > 0) {
				for (j = i - 1; j >= 0; j--) {
					rslt[j] = 0;					
				}
			}
			break;
		}
	}

	for (i = 0; i< shape_ub; i++){
		Prev_Index[i] = rslt[i];
	}
	if (rslt != NULL)	
		free(rslt);
} /* end NextIndex */

/* ***************************************************************
 **************************** copyIndices **********************
 ***************************************************************/

void copyIndicesElm (long offset, MOA_rec * MOA_in, MOA_rec * * rslt, long * ref_dimn, long * Last_ref_dimn, long * valid_index, int copyElemFlag, int analyzeLBHB, long * HB_ub, long * * HB, long * LB_ub, long * * LB) {
	long l1_finished, counter;
#ifndef NDEBUG
	char msg[MID_MESSAGE_SIZE];
	int dbglevel = 15;
#endif

	counter = 0;
	l1_finished = 0;
	if(analyzeLBHB == 1) {
		(*HB_ub) = 0;
		(*LB_ub) = 0;
	}
	while (l1_finished == 0) {
		(*rslt)->indexes[counter] = offset + Gamma(ref_dimn, MOA_in->dimn, MOA_in->shape, MOA_in->dimn, 1);
#ifndef NDEBUG
		sprintf(msg, "  %ld ", (*rslt)->indexes[counter]);
		mprintf (dbglevel, msg, 1);
#endif
		if (copyElemFlag == 1)
      	(*rslt)->elements[counter].val = MOA_in->elements[(*rslt)->indexes[counter]].val;	    	    
		else
			(*rslt)->elements[counter].val = 0;
		(*rslt)->elements[counter].prev = NULL;
		(*rslt)->elements[counter].prev_ub = 0;
		/*Begin AnalyzeCells*/
		if (analyzeLBHB == 1) {
			if (isLowerBorderCell(ref_dimn, (*rslt)->dimn) == 1) {
	  			(*LB_ub) ++;
	  			if ((*LB_ub) == 1)
	    			(*LB) = mmalloc (sizeof *(*LB));
	  			else
	    			(*LB) = realloc ((*LB), (*LB_ub) * sizeof *(*LB));
				(*LB)[(*LB_ub) - 1] = (*rslt)->indexes[counter];
			}
			if ( isHigherBorderCell (ref_dimn, (*rslt)->dimn, (*rslt)->shape) == 1) {
 	  			(*HB_ub) ++;
	  			if ((*HB_ub) == 1)
	    			(*HB) = mmalloc (sizeof *(*HB));
	  			else
	    			(*HB) = realloc ((*HB), (*HB_ub) * sizeof *(*HB));
	 	  		(*HB)[(*HB_ub) - 1] = (*rslt)->indexes[counter];
			}
		}
		/*Finish AnalyzeCells*/
		counter ++;
		l1_finished = VecIsEqual(ref_dimn, MOA_in->dimn, Last_ref_dimn, MOA_in->dimn);
		NextIndex(valid_index, MOA_in->dimn, ref_dimn);
	}
}

/**************************************************************************
	Function: copyIndices
**************************************************************************/
void copyIndices (long offset, long Sdimn, long * Sshape, MOA_rec * * rslt, long * ref_dimn, long * Last_ref_dimn, long * valid_index, int analyzeLBHB, long * HB_ub, long * * HB, long * LB_ub, long * * LB) {
	long l1_finished, counter;
#ifndef NDEBUG
	char msg[MID_MESSAGE_SIZE];
	int dbglevel = 4;
#endif

	counter = 0;
	l1_finished = 0;
	if(analyzeLBHB == 1) {
	  (*HB_ub) = 0;
	  (*LB_ub) = 0;
		/*printf ("cells for elms_ub %d lb_ub %d hb_ub %d\n", rslt->elements_ub, (*LB_ub), (*HB_ub));*/
	}
#ifndef NDEBUG
	mprintf (dbglevel, ">>>>Copy Indices {\n", 1);
#endif
	while (l1_finished == 0) {
		(*rslt)->indexes[counter] = offset + Gamma(ref_dimn, Sdimn, Sshape, Sdimn, 1);
#ifndef NDEBUG
		sprintf(msg, "  %ld ", (*rslt)->indexes[counter]);
		mprintf (dbglevel, msg, 1);
#endif
		(*rslt)->elements[counter].val = 0;
		(*rslt)->elements[counter].prev = NULL;
		(*rslt)->elements[counter].prev_ub = 0;
		/* Begin AnalyzeCells =======================================*/
		if (analyzeLBHB == 1) {
			if (isLowerBorderCell(ref_dimn, (*rslt)->dimn) == 1) {
				(*LB_ub) ++;
				if ((*LB_ub) == 1)
					(*LB) = mmalloc (sizeof *(*LB));
				else
					(*LB) = realloc ((*LB), (*LB_ub) * sizeof *(*LB));
	  
				(*LB)[(*LB_ub) - 1] = (*rslt)->indexes[counter];
			}
			if ( isHigherBorderCell (ref_dimn, (*rslt)->dimn, (*rslt)->shape) == 1) {
				(*HB_ub) ++;
				if ((*HB_ub) == 1)
					(*HB) = mmalloc (sizeof *(*HB));
				else
					(*HB) = realloc ((*HB), (*HB_ub) * sizeof *(*HB));
				(*HB)[(*HB_ub) - 1] = (*rslt)->indexes[counter];
			}
		}
		/* Finish AnalyzeCells =======================================*/
		counter ++;
		l1_finished = VecIsEqual(ref_dimn, Sdimn, Last_ref_dimn, Sdimn);
		NextIndex(valid_index, Sdimn, ref_dimn);
	}
#ifndef NDEBUG
	mprintf (dbglevel, "\n}\n", 1);
#endif
}

/* ***************************************************************
 **********************      Take      *************************
 ***************************************************************/

int Take (long * ind, long ind_ub, MOA_rec * MOA_in, MOA_rec * * rslt) {
	long * valid_index = NULL;
	long * ref_dimn = NULL;
	long * Last_ref_dimn = NULL;
	int negative, positive;
	long i;
	long offset;
#ifndef NDEBUG
	char msg[MID_MESSAGE_SIZE];
	int dbglevel = 4;
#endif
  
	negative = 0;
	positive = 0;
	/* decide from which direction to take */
	if (ind[0] >= 0) {
		positive = 1;
	}
	else {
		negative = 1;
	}
  
	(*rslt)->dimn = MOA_in->dimn;
  
	/* test the index parameter to form a valid index to the Psi function */
	if (MOA_in->dimn == 0) {
		valid_index = mmalloc (sizeof *valid_index);
		ref_dimn = mmalloc (sizeof *ref_dimn);
		Last_ref_dimn = mmalloc (sizeof *Last_ref_dimn);
		(*rslt)->shape = mmalloc (sizeof *((*rslt)->shape));
		if ((ind[0] > 0) && (ind[0] <= MOA_in->shape[0])) {
			if (negative == 1) {
				mprintf (0,"Take Error: Invalid index!\n", 1);
				return -1;
			}
			valid_index[0] = ind[0];
		}
		else if ((ind[0] < 0) && (abs(ind[0]) <= MOA_in->shape[0] + 1)) {
			if (positive == 1) {
				mprintf (0, "Take Error: Invalid index!\n", 1);
				return -1;
			}
			valid_index[0] = MOA_in->shape[0] - abs(ind[0]);
		}
		else {
			if (  !((ind[0] >= 0) && (ind[0] <= MOA_in->shape[0])) 
				&& !((ind[0] < 0) && (abs(ind[0]) <= MOA_in->shape[0] + 1 ) ) ) {
				mprintf (0, "Take Error: Invalid index!\n", 1);
				return -1;
			}
		}
	}
	else {
		valid_index = mmalloc (MOA_in->dimn * sizeof *valid_index);
		ref_dimn = mmalloc (MOA_in->dimn * sizeof *ref_dimn); 
		Last_ref_dimn =mmalloc (MOA_in->dimn * sizeof *Last_ref_dimn);
		(*rslt)->shape = mmalloc (MOA_in->dimn * sizeof *((*rslt)->shape));
		for (i = 0; i < MOA_in->dimn; i++) {
			if (ind_ub > i) {
				if ((ind[i] > 0) && (ind[i] <= MOA_in->shape[i])) {
					if (negative == 1) {
						mprintf (0, "Take Error: Invalid index!\n", 1);
	    				return -1;
					}
					valid_index[i] = ind[i];
				}
				else if ((ind[i] < 0) && (abs(ind[i]) <= MOA_in->shape[i] + 1)) {
					if (positive == 1) {
						mprintf (0, "Take Error: Invalid index!\n", 1);
						return -1;
					}
					valid_index[i] = MOA_in->shape[i] - abs(ind[i]);
				}
				else {
					if (  !((ind[i] >= 0) && (ind[i] <= MOA_in->shape[i])) 
						&& !((ind[i] < 0) && (abs(ind[i]) <= MOA_in->shape[i] + 1 ) ) ) {
						if (ind[i] >= 0)
							valid_index[i] = MOA_in->shape[i];
						else
							valid_index[i] = 0;
					}
				}
			}
			else {
				valid_index[i] = MOA_in->shape[i];
			}
		}
	}
#ifndef NDEBUG
	sprintf(msg, "\npositive %d and valid_indexes: {\n", positive);
	mprintf (dbglevel, msg, 1);
	for (i = 0; i < MOA_in->dimn; i++) {
		sprintf(msg, " %ld ", valid_index[i]);
		mprintf (dbglevel, msg, 1);
	}
	mprintf (dbglevel, "\n}\n and input ind: {\n", 1);
	for (i = 0; i < MOA_in->dimn; i++) {
		sprintf(msg, " %ld ", ind[i]);
		mprintf (dbglevel, msg, 1);
	}
	mprintf (dbglevel, "\n}\n and shape: {\n", 1);
	for (i = 0; i < MOA_in->dimn; i++) {
		sprintf(msg, " %ld ", MOA_in->shape[i]);
		mprintf (dbglevel, msg, 1);
	}
	mprintf (dbglevel, "\n}\n", 1);
#endif
	/*call the Psi function with the valid index parameter to return the required parition of the array */
	if (positive == 1) {
		if (MOA_in->dimn == 0) {
			ref_dimn[0] = 0;
			Last_ref_dimn[0] = valid_index[0] - 1;
			(*rslt)->shape[0] = valid_index[0];
		}
		else {
			for (i=0; i< MOA_in->dimn; i++) {
				ref_dimn[i] = 0;
				Last_ref_dimn[i] = valid_index[i] - 1;
				(*rslt)->shape[i] = valid_index[i];
			}
		}
		(*rslt)->elements_ub = Tau((*rslt)->shape, (*rslt)->dimn);
		(*rslt)->indexes = mcalloc ((*rslt)->elements_ub, sizeof *((*rslt)->indexes));
		(*rslt)->elements = mmalloc ((*rslt)->elements_ub * sizeof *((*rslt)->elements));
		if ((*rslt)->elements_ub == 1) 
			(*rslt)->dimn = 0;
#ifndef NDEBUG
		mprintf (dbglevel, "and  rslt->shape: {\n", 1);
		for (i = 0; i < MOA_in->dimn; i++) {
			sprintf(msg, " %ld ", (*rslt)->shape[i]);
			mprintf (dbglevel, msg, 1);
		}
		mprintf (dbglevel, "\n}\n", 1);
#endif
		copyIndicesElm(0, MOA_in, rslt, ref_dimn, Last_ref_dimn, valid_index, 1, 0, NULL, NULL, NULL, NULL);
	}
	else {
		if (MOA_in->dimn == 0) {
			if (abs(ind[0]) < MOA_in->shape[0]) {
				ind[0] = abs(ind[0]);
				(*rslt)->shape[0] = ind[0];
				ref_dimn[0] = 0;
				Last_ref_dimn[0] = ind[0] - 1;
			}
			else{
				valid_index[0] = 0;
				ind[0] = MOA_in->shape[0];
				(*rslt)->shape[0] = ind[0];
				ref_dimn[0] = 0;
				Last_ref_dimn[0] = ind[0] - 1;
			}
		}
		else {
			for (i = 0; i < MOA_in->dimn; i++) {
				if (abs(ind[i]) < MOA_in->shape[i]) {
					ind[i] = abs(ind[i]);
					(*rslt)->shape[i] = ind[i];
					ref_dimn[i] = 0;
					Last_ref_dimn[i] = ind[i] - 1;
				}
				else {
					valid_index[i] = 0;
					ind[i] = MOA_in->shape[i];
					(*rslt)->shape[i] = ind[i];
					ref_dimn[i] = 0;
					Last_ref_dimn[i] = ind[i] - 1;
				}
			}
		}
		(*rslt)->elements_ub = Tau((*rslt)->shape, (*rslt)->dimn);
		(*rslt)->indexes = mcalloc ((*rslt)->elements_ub, sizeof *((*rslt)->indexes));
		(*rslt)->elements = mmalloc ((*rslt)->elements_ub * sizeof *((*rslt)->elements));
		if ((*rslt)->elements_ub == 1) 
			(*rslt)->dimn = 0;
#ifndef NDEBUG
		mprintf (dbglevel, "and  rslt->shape: {\n", 1);
		for (i = 0; i < MOA_in->dimn; i++) {
      	sprintf(msg, " %ld ", (*rslt)->shape[i]);
      	mprintf (dbglevel, msg, 1);
		}
		mprintf (dbglevel, "\n}\n", 1);
#endif
		offset = Gamma(valid_index, MOA_in->dimn, MOA_in->shape, MOA_in->dimn, 1);
		copyIndicesElm(offset, MOA_in, rslt, ref_dimn, Last_ref_dimn, ind, 1, 0, NULL, NULL, NULL, NULL);
	}
  
	if (valid_index != NULL) 	
		free(valid_index);
	if (ref_dimn  != NULL) 
		free(ref_dimn);
	if (Last_ref_dimn != NULL)
		free(Last_ref_dimn);

	return 0;	
}

/* ***************************************************************
 *******  Take without creating the whole Tensor     ***********
 ***************************************************************/
int TakeInd (long * ind, long ind_ub, long Sdimn, long * Sshape, MOA_rec * * rslt, int analyzeLBHB, long * HB_ub, long * * HB, long * LB_ub, long * * LB) {
	long * valid_index = NULL;
	long * ref_dimn = NULL;
	long * Last_ref_dimn = NULL;
	long negative, positive;
	long offset, i;
#ifndef NDEBUG
	char msg[MID_MESSAGE_SIZE];
	int dbglevel = 4;
#endif

	negative = 0;
	positive = 0;
	/* decide from which direction to take*/
	if (ind[0] >= 0) {
		positive = 1;
	}
	else {
		negative = 1;
	}
  
	(*rslt)->dimn = Sdimn;

	/* test the index parameter to form a valid index to the Psi function*/
	if (Sdimn == 0) {
		valid_index = mmalloc (sizeof *valid_index);
		ref_dimn = mmalloc (sizeof *ref_dimn);
		Last_ref_dimn = mmalloc (sizeof *Last_ref_dimn);
		(*rslt)->shape = mmalloc (sizeof *(*rslt)->shape );
		if ((ind[0] > 0) && (ind[0] <= Sshape[0])) {
			if (negative == 1) {
				mprintf(0,"Take Error: Invalid index!\n", 1);
				return -1;
			}
			valid_index[0] = ind[0];
		}
		else if ((ind[0] < 0) && (abs(ind[0]) <= Sshape[0] + 1)) {
			if (positive == 1) {
				mprintf(0, "Take Error: Invalid index!\n", 1);
				return -1;
			}
			valid_index[0] = Sshape[0] - abs(ind[0]);
		}
		else {
			if (  !((ind[0] >= 0) && (ind[0] <= Sshape[0])) 
				&& !((ind[0] < 0) && (abs(ind[0]) <= Sshape[0] + 1 ) ) ) {
				mprintf(0, "Take Error: Invalid index!\n", 1);
				return -1;
			}
		}
	}
	else {
		valid_index = mmalloc (Sdimn * sizeof *valid_index);
		ref_dimn = mmalloc (Sdimn * sizeof *ref_dimn); 
		Last_ref_dimn =mmalloc (Sdimn * sizeof *Last_ref_dimn);
		(*rslt)->shape = mmalloc (Sdimn * sizeof *(*rslt)->shape );
		for (i = 0; i < Sdimn; i++) {
			if (ind_ub > i) {
				if ((ind[i] > 0) && (ind[i] <= Sshape[i])) {
					if (negative == 1) {
						mprintf(0, "Take Error: Invalid index!\n", 1);
						return -1;
					}
					valid_index[i] = ind[i];
				}
				else if ((ind[i] < 0) && (abs(ind[i]) <= Sshape[i] + 1)) {
					if (positive == 1) {
	   				mprintf(0, "Take Error: Invalid index!\n", 1);
						return -1;
					}
					valid_index[i] = Sshape[i] - abs(ind[i]);
				}
				else {
					if (  !((ind[i] >= 0) && (ind[i] <= Sshape[i])) 
						&& !((ind[i] < 0) && (abs(ind[i]) <= Sshape[i] + 1 ) ) ) {
						if (ind[i] >= 0)
							valid_index[i] = Sshape[i];
						else
							valid_index[i] = 0;
					}
				}
			} 
			else {
				valid_index[i] = Sshape[i];
			}
		}
	}
	/* call the Psi function with the valid index parameter to return the required parition of the array*/
	if (positive == 1) {
		if (Sdimn == 0) {
			ref_dimn[0] = 0;
			Last_ref_dimn[0] = valid_index[0] - 1;
			(*rslt)->shape[0] = valid_index[0];
		}
		else {
			for (i=0; i< Sdimn; i++) {
				ref_dimn[i] = 0;
				Last_ref_dimn[i] = valid_index[i] - 1;
				(*rslt)->shape[i] = valid_index[i];
			}
		}
		(*rslt)->elements_ub = Tau((*rslt)->shape, (*rslt)->dimn);
		(*rslt)->indexes = mcalloc ((*rslt)->elements_ub, sizeof *((*rslt)->indexes));
		(*rslt)->elements = mcalloc ((*rslt)->elements_ub, sizeof *((*rslt)->elements));
		if ((*rslt)->elements_ub == 1) 
			(*rslt)->dimn = 0;
    
   
#ifndef NDEBUG
		mprintf (dbglevel, "\nand  rslt->shape:{\n", 1);
		for (i = 0; i < Sdimn; i++) {
			sprintf (msg, " %ld ", (*rslt)->shape[i]);
			mprintf (dbglevel, msg, 1);
		}
		mprintf (dbglevel, "\n}\n", 1);
#endif
		copyIndices(0, Sdimn, Sshape, rslt, ref_dimn, Last_ref_dimn, valid_index, analyzeLBHB, HB_ub, HB, LB_ub, LB);
	}
	else {
		if (Sdimn == 0) {
			if (abs(ind[0]) < Sshape[0]) {
				ind[0] = abs(ind[0]);
				(*rslt)->shape[0] = ind[0];
				ref_dimn[0] = 0;
				Last_ref_dimn[0] = ind[0] - 1;
			}
			else{
				valid_index[0] = 0;
				ind[0] = Sshape[0];
				(*rslt)->shape[0] = ind[0];
				ref_dimn[0] = 0;
				Last_ref_dimn[0] = ind[0] - 1;
			}
		}
		else {
			for (i = 0; i < Sdimn; i++) {
				if (abs(ind[i]) < Sshape[i]) {
					ind[i] = abs(ind[i]);
					(*rslt)->shape[i] = ind[i];
					ref_dimn[i] = 0;
					Last_ref_dimn[i] = ind[i] - 1;
				}
				else {
					valid_index[i] = 0;
					ind[i] = Sshape[i];
					(*rslt)->shape[i] = ind[i];
					ref_dimn[i] = 0;
					Last_ref_dimn[i] = ind[i] - 1;
				}
			}
		}
		(*rslt)->elements_ub = Tau((*rslt)->shape, (*rslt)->dimn);
		(*rslt)->indexes = mcalloc ((*rslt)->elements_ub, sizeof *((*rslt)->indexes));
		(*rslt)->elements = mcalloc ((*rslt)->elements_ub, sizeof *((*rslt)->elements));
		if ((*rslt)->elements_ub == 1) 
			(*rslt)->dimn = 0;

#ifndef NDEBUG
		mprintf (dbglevel, "\nand  rslt->shape: {\n", 1);
		for (i = 0; i < Sdimn; i++) {
			sprintf (msg, " %ld ", (*rslt)->shape[i]);
			mprintf (dbglevel, msg, 1);
		}
		mprintf (dbglevel, "\n}\n", 1);
#endif
		offset = Gamma(valid_index, Sdimn, Sshape, Sdimn, 1);
		copyIndices(offset, Sdimn, Sshape, rslt, ref_dimn, Last_ref_dimn, ind, analyzeLBHB, HB_ub, HB, LB_ub, LB);
	}
  
	if (valid_index != NULL) 	
		free(valid_index);
	if (ref_dimn  != NULL) 
		free(ref_dimn);
	if (Last_ref_dimn != NULL)
		free(Last_ref_dimn);
	return 0;	
}

/* ***************************************************************
 **********************      Drop      *************************
 ***************************************************************/
int Drop (long * ind, long ind_ub, MOA_rec * MOA_in, MOA_rec * * rslt) {
	long * valid_index = NULL;
	int positive, negative, ret;
	long i;
	char msg[MID_MESSAGE_SIZE];
#ifndef NDEBUG
	int dbglevel = 4;
#endif

	negative = 0;
	positive = 0;
  
	if (ind[0] >= 0) {
		positive = 1;
	} 
	else {
		negative = 1;
	}
  
	if (MOA_in->dimn == 0) {
		valid_index = mmalloc (sizeof *valid_index);
		if ((ind[0] >= 0) && ( ind[0] < MOA_in->shape[0])) {
			if (negative == 1) {
				mprintf(0, "Drop Error: Invalid index!\n", 1);
				return -1;
			}
			valid_index[0] = MOA_in->shape[0] - ind[0];
		}
		else if ((ind[0] < 0) && (abs(ind[0]) <= MOA_in->shape[0])) {
			if (positive == 1) {
				mprintf(0, "Drop Error: Invalid index!\n", 1);
				return -1;
			}
			valid_index[0] = MOA_in->shape[0] - abs(ind[0]);
		}
		else {
			mprintf(0, "Drop Error: Invalid index!\n", 1);
      	return -1;
		}
	}
	else {
		valid_index = mmalloc(MOA_in->dimn * sizeof *valid_index);
		for (i = 0; i < MOA_in->dimn; i++) {
			if (ind_ub > i) {
				if ((ind[i] >= 0) && ( ind[i] < MOA_in->shape[i])) {
					if (negative == 1) {
						sprintf(msg, "Drop Error: Invalid index at dimension %ld!\n", i);
						mprintf (0, msg, 1);
						return -1;
					}
					valid_index[i] = MOA_in->shape[i] - ind[i];
				}
				else if ((ind[i] < 0) && (abs(ind[i]) <= MOA_in->shape[i])) {
					if (positive == 1) {
						sprintf(msg, "Drop Error: Invalid index at dimension %ld!\n", i);
						mprintf (0, msg, 1);
						return -1;
					}
					valid_index[i] = MOA_in->shape[i] - abs(ind[i]);
				}
				else {
					sprintf(msg, "Drop Error: Invalid index at dimension %ld!\n", i);
					mprintf (0, msg, 1);
					return -1;
				}
			}
			else {
				valid_index[i] = MOA_in->shape[i];
			}
		}
	}
  
	if (ind_ub == 0) {
		valid_index[0] = MOA_in->shape[0] - ind[0];
	}
  
	if (positive) {
		if (MOA_in->dimn  == 0) {
			valid_index[0] = valid_index[0] * (-1);
		}
		else {
			for (i = 0; i < MOA_in->dimn; i ++) {
				valid_index[i] = valid_index[i] * (-1);
			}
		}
	}    
#ifndef NDEBUG
	mprintf (dbglevel, "\nin drop before take with valid index =  {\n", 1);
	for (i = 0; i < MOA_in->dimn; i ++) {
		sprintf(msg, " %ld ", valid_index[i]);
		mprintf (dbglevel, msg, 1);
	}
	mprintf (dbglevel, "\n}\n and  MOA_in->shape =  {\n", 1);
	for (i = 0; i < MOA_in->dimn; i ++) {
		sprintf(msg, " %ld ", MOA_in->shape[i]);
		mprintf (dbglevel, msg, 1);
	}
	mprintf (dbglevel, "\n}\n and  ind  =  {\n", 1);
	for (i = 0; i < MOA_in->dimn; i ++) {
		sprintf(msg, " %ld ", ind[i]);
		mprintf (dbglevel, msg, 1);
	}
	mprintf (dbglevel, "\n}\n", 1);
#endif
	ret = Take(valid_index, MOA_in->dimn, MOA_in, rslt);
  
	if (valid_index != NULL) 	
		free (valid_index);
  
	return ret;
}

/* ***************************************************************
 *******  Drop without creating the whole Tensor  **************
 ***************************************************************/
int DropInd (long * ind, long ind_ub, long Sdimn, long * Sshape, MOA_rec * * rslt) {
	long * valid_index = NULL;
	int positive, negative, ret;
	long i;
	char msg[MID_MESSAGE_SIZE];
#ifndef NDEBUG
	int dbglevel = 4;
#endif
	
	negative = 0;
	positive = 0;
	if (ind[0] >= 0) {
		positive = 1;
	} 
	else {
		negative = 1;
	}
	
	if (Sdimn == 0) {
		valid_index = mmalloc (sizeof *valid_index);
		if ((ind[0] >= 0) && ( ind[0] < Sshape[0])) {
			if (negative == 1) {
				mprintf(0, "Drop Error: Invalid index!\n", 1);
				return -1;
      	}
	      valid_index[0] = Sshape[0] - ind[0];
		}
		else if ((ind[0] < 0) && (abs(ind[0]) <= Sshape[0])) {
			if (positive == 1) {
				mprintf(0, "Drop Error: Invalid index!\n", 1);
				return -1;
			}
      	valid_index[0] = Sshape[0] - abs(ind[0]);
		}
		else {
			mprintf(0, "Drop Error: Invalid index!\n", 1);
      	return -1;
		}
  	}
	else {
		valid_index = mmalloc(Sdimn * sizeof(long));
		for (i = 0; i < Sdimn; i++) {
			if (ind_ub > i) {
				if ((ind[i] >= 0) && ( ind[i] < Sshape[i])) {
					if (negative == 1) {
						sprintf(msg, "Drop Error: Invalid index at dimension %ld!\n", i);
						mprintf (0, msg, 1);
						return -1;
					}
					valid_index[i] = Sshape[i] - ind[i];
				}
				else if ((ind[i] < 0) && (abs(ind[i]) <= Sshape[i])) {
					if (positive == 1) {
						sprintf(msg, "Drop Error: Invalid index at dimension %ld!\n", i);
						mprintf (0, msg, 1);
						return -1;
					}
					valid_index[i] = Sshape[i] - abs(ind[i]);
				}
				else {
					sprintf(msg, "Drop Error: Invalid index at dimension %ld!\n", i);
					mprintf (0, msg, 1);
					return -1;
				}
			}
			else {
				valid_index[i] = Sshape[i];
			}
		}
	}
  
	if (ind_ub == 0) {
		valid_index[0] = Sshape[0] - ind[0];
	}
  
	if (positive) {
		if (Sdimn  == 0) {
			valid_index[0] = valid_index[0] * (-1);
		}
		else {
			for (i = 0; i < Sdimn; i ++) {
				valid_index[i] = valid_index[i] * (-1);
			}
		}
	}    
  
#ifndef NDEBUG
	mprintf (dbglevel, "\nin drop before take with valid index =  {\n", 1);  
	for (i = 0; i < Sdimn; i ++) {
		sprintf(msg, " %ld ", valid_index[i]);
		mprintf (dbglevel, msg, 1);
	}
	mprintf (dbglevel, "}\nand  Sshape =  {\n", 1);
	for (i = 0; i < Sdimn; i ++) {
		sprintf(msg, " %ld ", Sshape[i]);
		mprintf (dbglevel, msg, 1);
	}
	mprintf (dbglevel, "\n}\nand  ind  =  {\n", 1);
	for (i = 0; i < Sdimn; i ++) {
		sprintf(msg, " %ld ", ind[i]);
		mprintf (dbglevel, msg, 1);
	}
	mprintf (dbglevel, "\n}\n", 1);
#endif
	ret = TakeInd(valid_index, Sdimn, Sdimn, Sshape, rslt, 0, NULL, NULL, NULL, NULL);
  
	if (valid_index != NULL) 	
		free (valid_index);
  
	return ret;
}
/* ***************************************************************
 **********************    MOAGetHigherNeighbors ****************
 ***************************************************************/
long MOAGetHigherNeighbors (long stride, long * startingIndex, long Sdimn, long * Sshape, MOA_rec * * rslt, long * HB_ub, long * * HB, long * LB_ub, long * * LB) {
	long i, idx, * ind, * ind2, * ind3, * ind4;
	int l1_finished, ret, noDrop;

	ind = NULL;
	ind =  mmalloc (Sdimn * sizeof *ind);
	if (ind == NULL) 
		return 0;

	ind2 = NULL;
	ind2 =  mmalloc (Sdimn * sizeof *ind2);
	if (ind2 == NULL) 
		return 0;

	ind3 = NULL;
	ind3 =  mmalloc (Sdimn * sizeof *ind3);
	if (ind3 == NULL) 
		return 0;

	ind4 = NULL;
	ind4 =  mmalloc (Sdimn * sizeof *ind4);
	if (ind4 == NULL) 
		return 0;

	MOA_rec * rslt2;
	noDrop = 1;
	for (i = 0; i < Sdimn; i++) {
		if (startingIndex[i] > Sshape[i] - 1)
			return 0;
		else {
			ind[i] = stride;
			ind2[i] = startingIndex[i];
			if (ind2[i] > 0)
				noDrop = 0;
		}
	}
	if (noDrop == 0) {
		createMOAStruct (&rslt2);
		ret = DropInd(ind2, Sdimn, Sdimn, Sshape, &rslt2);  
		if (ret >= 0) {
     		createMOAStruct (rslt);
	    	ret = TakeInd(ind, rslt2->dimn, rslt2->dimn, rslt2->shape, rslt, 0, NULL, NULL, NULL, NULL); 
  			if (ret < 0) 
      		return 0;
	  	}

  		for (i = 0; i < Sdimn; i++) {
    		ind[i] = 0;
	    	ind3[i] = (*rslt)->shape[i];
   	 	ind2[i] = ind3[i] - 1;
  		}
  	
		l1_finished = 0;
		i = 0;
		if (LB_ub != NULL)
	  		(*LB_ub) = 0;
  		if (HB_ub != NULL)
			(*HB_ub) = 0;
		if ((*rslt)->elements_ub > 0) {
			while (l1_finished == 0) {
				idx = Gamma(ind, rslt2->dimn, rslt2->shape, rslt2->dimn, 1);
	      	(*rslt)->indexes[i] =  rslt2->indexes[idx];
				if (LB_ub != NULL) {
					if (isLowerBorderCell(ind, (*rslt)->dimn) == 1) {
						(*LB_ub) ++;
	  					if ((*LB_ub) == 1)
	    					(*LB) = mmalloc (sizeof *(*LB));
	  					else
	    					(*LB) = realloc ((*LB), (*LB_ub) * sizeof *(*LB));
	  					(*LB)[(*LB_ub) - 1] = (*rslt)->indexes[i];
	  				}
				}
				if (HB_ub != NULL) {
					if ( isHigherBorderCell (ind, (*rslt)->dimn, (*rslt)->shape) == 1) {
 		  				(*HB_ub) ++;
	  					if ((*HB_ub) == 1)
	    					(*HB) = mmalloc (sizeof *(*HB));
	  					else
	    					(*HB) = realloc ((*HB), (*HB_ub) * sizeof *(*HB));
	 	  				(*HB)[(*HB_ub) - 1] = (*rslt)->indexes[i];      	
	 	  			}
    			}
    			i++;
    			l1_finished = VecIsEqual(ind, Sdimn, ind2, Sdimn);
      		NextIndex(ind3, Sdimn, ind);
			}
		} 
		deleteMOA (rslt2);  
	}
	else {
		createMOAStruct (rslt);
		ret = TakeInd(ind, Sdimn, Sdimn, Sshape, rslt, 1, HB_ub, HB, LB_ub, LB);
		if (ret < 0) 
			return 0;
	}
  
	if (ind != NULL)
		free(ind);
	if (ind2 != NULL)
		free(ind2);
	if (ind3 != NULL)
		free(ind3);
	if (ind4 != NULL)
		free(ind4);

	return (*rslt)->elements_ub-1;
}
@


1.1
log
@Initial revision
@
text
@d36 53
a103 11
/* ***************************************************************
* Function: Gamma
* Description: Get flay index of MOA array
*****************************************************************/
long Gamma (long * m_index, long ind_ub, long * arr_shape, long shape_ub, int Front) {
	long rslt, i;
	rslt = m_index[shape_ub - 1];
	for (i = shape_ub - 2; i>=0;i--) {
		rslt = (rslt * arr_shape[i]) + m_index[i];
   }
	return rslt;
a104 1
}
d112 1
a112 1
	int dbglevel = 10;
d153 14
a192 5
/*****************************************************
	Function: createMOAStruct
		Allocate memory for MOA record and initialize its elements.
*****************************************************/
void createMOAStruct(MOA_rec * * MOA_val) {
a193 45
  (*MOA_val) = mmalloc(sizeof *(*MOA_val));
  (*MOA_val)->dimn = 1;
  (*MOA_val)->shape = NULL;
  (*MOA_val)->indexes = NULL;
  (*MOA_val)->elements = NULL;
}

void createMOA(long * shape, long dimn, MOA_rec * MOA_val, int callFlag, int cellValue)
{
  long i;
  
  MOA_val->elements_ub = Tau(shape, dimn);
  if (MOA_val->elements_ub == 0) {
    mprintf(1, "The smallest type of MOA array is a scalar that requires at least one element! NO MOA type supports zero element list!\n", threadnum);
    return;
  }
  MOA_val->dimn = dimn;
  if (dimn == 0) {
    MOA_val->shape = mcalloc (1, sizeof *MOA_val->shape);
    MOA_val->shape[0] = 1;
  }
  else {
    MOA_val->shape = mcalloc(MOA_val->dimn, sizeof *MOA_val->shape);
    for (i = 0; i< dimn; i++) {
      MOA_val->shape[i] = shape[i];
    }
  }
  /* if callFlag is -1 means, don't allocate memory for the tensor, this is used with sparse arrays implementation. */
  
  if (callFlag != -1) {
    
    /*MOA_val->elements_ub =  Tau(shape, dimn); */
    MOA_val->elements = mcalloc (MOA_val->elements_ub, sizeof *MOA_val->elements);
    MOA_val->indexes = mcalloc (MOA_val->elements_ub, sizeof *MOA_val->indexes);    
    for (i = 0; i< MOA_val->elements_ub; i++) {	MOA_val->elements[i].prev_ub = 0;	
	MOA_val->elements[i].prev = NULL;
	MOA_val->indexes[i] = i;
	/* if callFlag is 0, means initialize cell values with 0, which is done with mcalloc */	if (callFlag == 1) {
	/* if callFlag is 1 meaning, initialize the array values with the cellValue argument value */
	  MOA_val->elements[i].val = cellValue;
	}
    }
  }
  
}
d284 1
a284 1
	for (i = 0; i < MOA->shape[2]; i++) {
d336 1
a336 2
void printMOA1 (MOA_rec * MOA) { 
#ifndef NDEBUG
d338 1
d340 1
d347 5
a351 1
  sprintf(msg, "\n The Tensor of Dimn %ld & elements %ld & Shape: ", MOA->dimn, MOA->elements_ub);
d404 5
a408 2
  for (i = 0; i < MOA->elements_ub; i++) {
    sprintf(msg, "%5ld ", MOA->elements[i].val);
d459 123
a581 1
#endif
d754 1
a754 1
		rslt = 0;
d756 1
a756 1
		rslt = 1;
d760 1
a760 1
			rslt = 0;
d778 1
a778 1
	ind =  mmalloc (MOA_in->dimn * sizeof *ind);
d783 1
a783 1
	ind2 =  mmalloc (MOA_in->dimn * sizeof *ind2);
d788 1
a788 1
	ind3 =  mmalloc (MOA_in->dimn * sizeof *ind);
d797 6
a802 3
	noDrop = 1;
	for (i = 0; i < MOA_in->dimn; i++) {
		ind[i] = 2;
d808 2
a809 1
      	noDrop = 0;
d811 1
d815 2
a816 1
		ret = Drop(ind2, MOA_in->dimn, MOA_in, &rslt2);  
d820 1
a820 1
  	}
d822 2
a823 2
  	if (ret < 0) 
    	return 0;
d825 6
a830 5
  	for (i = 0; i < MOA_in->dimn; i++) {
    	ind[i] = 0;
    	ind2[i] = 1;
    	ind3[i] = 2;
  	}
d832 15
a846 11
  	l1_finished = 0;
  	i = 0;
  	if ((*rslt)->elements_ub > 0) {
    	while (l1_finished == 0) {
      	idx = Gamma(ind, rslt2->dimn, rslt2->shape, rslt2->dimn, 1);
      	(*rslt)->indexes[i] =  rslt2->indexes[idx];
      	i++;
      	l1_finished = VecIsEqual(ind, MOA_in->dimn, ind2, MOA_in->dimn);
      	NextIndex(ind3, MOA_in->dimn, ind);
    	}
  	}
d850 1
a850 1
			createMOAStruct (rslt);
d852 6
a857 1
 	} 
@


1.1.1.1
log
@Distributed Optimal MSA using MoA
@
text
@@
